'use strict';

//dependencies
var fs      = require('fs');
var path    = require('path');
var async   = require('async');
var Cookies = require('cookies');
var util    = require('../util.js');
var mime    = require('mime');

module.exports = function RequestHandlerModule(pb) {
    /**
     * A mapping that provides the interface type to parse the body based on the
     * route specification
     * @private
     * @static
     * @readonly
     * @deprecated
     * @property BODY_PARSER_MAP
     * @type {Object}
     */
    class RequestHandler {
        constructor(req, resp) {
            /**
             * @property req
             * @type {Request}
             */
            this.req = req;
            /**
             * @property resp
             * @type {Response}
             */
            this.resp = resp;
            /**
             * @property errorCount
             * @type {number}
             */
            this.errorCount = 0;
        }
        /**
             * Derives the locale and localization instance.
         * @deprecated pending Serve Error
             * @method deriveLocalization
             * @param {Object} context
             * @param {Object} [context.session]
             * @param {String} [context.routeLocalization]
             */
        deriveLocalization(context) {
            var opts = {};
            var sources = [
                context.routeLocalization
            ];
            if (context.session) {
                sources.push(context.session.locale);
            }
            sources.push(this.req.headers[pb.Localization.ACCEPT_LANG_HEADER]);
            if (this.siteObj) {
                opts.supported = Object.keys(this.siteObj.supportedLocales);
                opts.site = this.siteObj.uid;
                sources.push(this.siteObj.defaultLocale);
            }
            var localePrefStr = sources.reduce(function (prev, curr, i) {
                return prev + (curr ? (!!i && !!prev ? ',' : '') + curr : '');
            }, '');
            opts.activeTheme = this.activeTheme || RequestHandler.DEFAULT_THEME;
            //get locale preference
            return new pb.Localization(localePrefStr, opts);
        }

        /**
         * @deprecated V1.0 awaiting usage of public controller.js
         * @param absolutePath
         */
        servePublicContent(absolutePath) {
            //check for provided path, then default if necessary
            if (util.isNullOrUndefined(absolutePath)) {
                absolutePath = path.join(pb.config.docRoot, 'public', this.url.pathname);
            }
            var self = this;
            fs.readFile(absolutePath, function (err, content) {
                if (err) {
                    //TODO [1.0] change default content type to JSON and refactor public file serving so it falls inline with other controller functions
                    self.route = !!self.route ? Object.assign({}, self.route) : {};
                    self.route.content_type = 'application/json';
                    return self.serve404();
                }
                //build response structure
                //guess at content-type
                var data = {
                    content: content,
                    content_type: mime.lookup(absolutePath)
                };
                //send response
                self.writeResponse(data);
            });
        }
        /**
             * Serves up a 404 page when the path specified by the incoming request does
             * not exist. This function <b>WILL</b> close the connection.
             * @method serve404
         * @deprecated as of V 1.0
             */
        serve404() {
            var error = new Error('NOT FOUND');
            error.code = 404;
            this.serveError(error);
            if (pb.log.isSilly()) {
                pb.log.silly("RequestHandler: No Route Found, Sending 404 for URL=" + this.url.href);
            }
        }
        /**
             * Serves up an error page.  The page is responsible for displaying an error page
             * @method serveError
             * @deprecated as of V 1.0
             * @param {Error} err The failure that was generated by the executed controller
             * @return {Boolean} TRUE when the error is rendered, FALSE if the request had already been handled
             */
        serveError(err, options) {
            if (this.resp.headerSent) {
                return false;
            }
            if (!options) {
                options = {};
            }
            //default the options object
            options = options || {};
            //bump the error count so handlers will know if we are recursively trying to handle errors.
            this.errorCount++;
            //retrieve the active theme.  Sometimes we don't have it such as in the case of the 404.
            var self = this;
            var getActiveTheme = function (cb) {
                if (self.activeTheme) {
                    return cb(null, self.activeTheme);
                }
                self.siteObj = self.siteObj || pb.SiteService.getGlobalSiteContext();
                var settingsService = pb.SettingServiceFactory.getService(pb.config.settings.use_memory, pb.config.settings.use_cache, self.siteObj.uid);
                settingsService.get('active_theme', function (err, activeTheme) {
                    self.activeTheme = activeTheme || pb.config.plugins.default;
                    cb(null, self.activeTheme);
                });
            };
            getActiveTheme(function (error, activeTheme) {
                self.localizationService = self.deriveLocalization({ session: self.session });
                //build out params for handlers
                self.localizationService = self.localizationService || self.deriveLocalization({});
                var params = {
                    mime: self.route && self.route.content_type ? self.route.content_type : 'text/html',
                    error: err,
                    request: self.req,
                    localization: self.localizationService,
                    activeTheme: activeTheme,
                    reqHandler: self,
                    errorCount: self.errorCount
                };
                //hand off to the formatters.  NOTE: the callback may not be called if
                //the handler chooses to fire off a controller.
                var handler = options.handler || function (data) {
                    self.onRenderComplete(data);
                };
                pb.ErrorFormatters.formatForMime(params, function (error, result) {
                    if (util.isError(error)) {
                        pb.log.error('RequestHandler: An error occurred attempting to render an error: %s', error.stack);
                    }
                    var data = {
                        reqHandler: self,
                        content: result.content,
                        content_type: result.mime,
                        code: err.code || 500
                    };
                    handler(data);
                });
            });
            return true;
        }
        /**
         *
         * @method onRenderComplete
         * @deprecated pending Serve Error
         * @param {Error|object} data
         * @param {string} [data.redirect]
         * @param {Integer} [data.code
         */
        onRenderComplete(data){
            if (util.isError(data)) {
                return this.serveError(data);
            }

            //set cookie
            var cookies = new Cookies(this.req, this.resp);
            if (this.setSessionCookie) {
                try{
                    cookies.set(pb.SessionHandler.COOKIE_NAME, this.session.uid, pb.SessionHandler.getSessionCookie(this.session));
                }
                catch(e){
                    pb.log.error('RequestHandler: %s', e.stack);
                }
            }

            //do any necessary redirects
            var doRedirect = typeof data.redirect !== 'undefined';
            if(doRedirect) {
                this.doRedirect(data.redirect, data.statusCode);
            }
            else {
                //output data here
                this.writeResponse(data);
            }

            //calculate response time
            if (pb.log.isDebug()) {
                pb.log.debug("Response Time: "+(new Date().getTime() - this.startTime)+
                        "ms URL=["+this.req.method+']'+
                        this.req.url+(doRedirect ? ' Redirect='+data.redirect : '') +
                        (typeof data.code === 'undefined' ? '' : ' CODE='+data.code));
            }

            //close session after data sent
            //public content doesn't require a session so in order to not error out we
            //check if the session exists first.
            if (this.session) {
                var self = this;
                pb.session.close(this.session, function(err/*, result*/) {
                    if (util.isError(err)) {
                        pb.log.warn('RequestHandler: Failed to close session [%s]', self.session.uid);
                    }
                });
            }
        };

        /**
             *
             * @method writeResponse
             * @param {Object} data
             */
        writeResponse(data) {
            var self = this;
            //infer a response code when not provided
            if (!data.code) {
                data.code = 200;
            }
            // If a response code other than 200 is provided, force that code into the head
            var contentType = 'text/html';
            if (typeof data.content_type !== 'undefined') {
                contentType = data.content_type;
            }
            else if (this.route && this.route.content_type !== undefined) {
                contentType = this.route.content_type;
            }
            //send response
            //the catch allows us to prevent any plugins that callback trwice from
            //screwing us over due to the attempt to write headers twice.
            try {
                //set any custom headers
                if (util.isObject(data.headers)) {
                    Object.keys(data.headers).forEach(function (header) {
                        self.resp.setHeader(header, data.headers[header]);
                    });
                }
                if (pb.config.server.x_powered_by) {
                    try {
                        this.resp.setHeader('x-powered-by', pb.config.server.x_powered_by);
                    }
                    catch (e) {
                        pb.log.error('Failed to set cookie, callback probably called twice: %s', e.stack);
                    }
                }
                this.resp.setHeader('Access-Control-Allow-Origin', pb.SiteService.getHostWithProtocol(this.hostname));
                this.resp.setHeader('content-type', contentType);
                this.resp.writeHead(data.code);
                //write content
                var content = data.content;
                if (!Buffer.isBuffer(content) && util.isObject(data.content)) {
                    content = JSON.stringify(content);
                }
                this.resp.end(content);
            }
            catch (e) {
                pb.log.error('RequestHandler: ' + e.stack);
            }
        }
        /**
             *
             * @method doRedirect
            * @deprecated pending Serve Error
            * @param {String} location
             * @param {Integer} [statusCode=302]
             */
        doRedirect(location, statusCode) {
            this.resp.statusCode = statusCode || pb.HttpStatus.MOVED_TEMPORARILY;
            this.resp.setHeader("Location", location);
            this.resp.end();
        }
        /**
             * Checks to see if the URL exists in the current context of the system
             * @static
             * @deprecated awaiting move to page/article base controller
             * @method urlExists
             * @param {String} url
             * @param {string} id
             * @param {string} [site]
             * @param {function} cb (Error, boolean)
             */
        static urlExists(url, id, site, cb) {
            var dao = new pb.DAO();
            if (typeof site === 'function') {
                cb = site;
                site = undefined;
            }
            var getTask = function (collection) {
                return function (callback) {
                    var where = { url: url };
                    if (site) {
                        where.site = site;
                    }
                    if (id) {
                        where[pb.DAO.getIdField()] = pb.DAO.getNotIdField(id);
                    }
                    dao.count(collection, where, function (err, count) {
                        if (util.isError(err) || count > 0) {
                            callback(true, count);
                        }
                        else {
                            callback(null, count);
                        }
                    });
                };
            };
            async.series([getTask('article'), getTask('page')], function (err /*, results*/) {
                cb(err, err !== null);
            });
        }
        /**
             * Determines if the provided URL pathname "/admin/content/articles" is a valid admin URL.
             * @static
             * @method isAdminURL
             * @param {String} urlPath
             * @return {boolean}
             */
        static isAdminURL(urlPath) {
            if (urlPath !== null) {
                var index = urlPath.indexOf('/');
                if (index === 0 && urlPath.length > 0) {
                    urlPath = urlPath.substring(1);
                }
                var pieces = urlPath.split('/');
                return pieces.length > 0 && pieces[0].indexOf('admin') === 0;
            }
            return false;
        }
        /**
             *
             * @static
             * @method isSystemSafeURL
             * @param {String} url
             * @param {String} id
             * @param {string} [site]
             * @param {Function} cb
             */
        static isSystemSafeURL(url, id, site, cb) {
            if (typeof site === 'function') {
                cb = site;
                site = undefined;
            }
            if (url === null || RequestHandler.isAdminURL(url)) {
                return cb(null, false);
            }
            RequestHandler.urlExists(url, id, site, function (err, exists) {
                cb(err, !exists);
            });
        }

        /**
             * Builds out the context that is passed to a controller
             * @static
             * @method buildControllerContext
             * @param {Request} req
             * @returns {Object}
             */
        // TODO: migrate this somewhere else other than here
        static buildControllerContext(ctx) {
            return {
                ctx,
                request: ctx.req,
                response: ctx.res,
                session: ctx.session,
                localization_service: ctx.req.localizationService,
                path_vars: ctx.params, // TODO: Remove this one
                pathVars: ctx.params,
                query: ctx.query,
                body: ctx.req.body,
                site: ctx.req.site,
                siteObj: ctx.req.siteObj,
                siteName: ctx.req.siteName,
                activeTheme: ctx.req.activeTheme || 'pencilblue',
                routeLocalized: !!(ctx.req.route ? ctx.req.route.localization : false)
            };
        }
    }

    // TODO: Migrate somewhere else other than here
    RequestHandler.DEFAULT_THEME = pb.config.plugins.default;

    return RequestHandler;
};
